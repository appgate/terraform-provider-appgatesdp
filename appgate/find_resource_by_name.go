// Code generated by go generate; DO NOT EDIT.
package appgate

import (
	"context"
	"github.com/appgate/sdp-api-client-go/api/v18/openapi"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"log"
)

func findEntitlementByUUID(ctx context.Context, api *openapi.EntitlementsApiService, id, token string) (*openapi.Entitlement, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source Entitlement get by UUID %s", id)
	resource, _, err := api.EntitlementsIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findEntitlementByName(ctx context.Context, api *openapi.EntitlementsApiService, name, token string) (*openapi.Entitlement, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source Entitlement get by name %s", name)

	resource, _, err := api.EntitlementsGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple Entitlement matched; use additional constraints to reduce matches to a single Entitlement")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find Entitlement %s", name)
}

func ResolveEntitlementFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.EntitlementsApiService, token string) (*openapi.Entitlement, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("entitlement_id")
	resourceName, nok := d.GetOk("entitlement_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of entitlement_id or entitlement_name attributes")
	}

	if iok {
		return findEntitlementByUUID(ctx, api, resourceID.(string), token)
	}
	return findEntitlementByName(ctx, api, resourceName.(string), token)
}

func findAdministrativeRoleByUUID(ctx context.Context, api *openapi.AdminRolesApiService, id, token string) (*openapi.AdministrativeRole, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source AdministrativeRole get by UUID %s", id)
	resource, _, err := api.AdministrativeRolesIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findAdministrativeRoleByName(ctx context.Context, api *openapi.AdminRolesApiService, name, token string) (*openapi.AdministrativeRole, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source AdministrativeRole get by name %s", name)

	resource, _, err := api.AdministrativeRolesGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple AdministrativeRole matched; use additional constraints to reduce matches to a single AdministrativeRole")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find AdministrativeRole %s", name)
}

func ResolveAdministrativeRoleFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.AdminRolesApiService, token string) (*openapi.AdministrativeRole, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("administrativerole_id")
	resourceName, nok := d.GetOk("administrativerole_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of administrativerole_id or administrativerole_name attributes")
	}

	if iok {
		return findAdministrativeRoleByUUID(ctx, api, resourceID.(string), token)
	}
	return findAdministrativeRoleByName(ctx, api, resourceName.(string), token)
}

func findApplianceCustomizationByUUID(ctx context.Context, api *openapi.ApplianceCustomizationsApiService, id, token string) (*openapi.ApplianceCustomization, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source ApplianceCustomization get by UUID %s", id)
	resource, _, err := api.ApplianceCustomizationsIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findApplianceCustomizationByName(ctx context.Context, api *openapi.ApplianceCustomizationsApiService, name, token string) (*openapi.ApplianceCustomization, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source ApplianceCustomization get by name %s", name)

	resource, _, err := api.ApplianceCustomizationsGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple ApplianceCustomization matched; use additional constraints to reduce matches to a single ApplianceCustomization")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find ApplianceCustomization %s", name)
}

func ResolveApplianceCustomizationFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.ApplianceCustomizationsApiService, token string) (*openapi.ApplianceCustomization, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("appliancecustomization_id")
	resourceName, nok := d.GetOk("appliancecustomization_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of appliancecustomization_id or appliancecustomization_name attributes")
	}

	if iok {
		return findApplianceCustomizationByUUID(ctx, api, resourceID.(string), token)
	}
	return findApplianceCustomizationByName(ctx, api, resourceName.(string), token)
}
