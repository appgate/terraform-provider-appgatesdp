// Code generated by go generate; DO NOT EDIT.
package appgate

import (
	"context"
	"github.com/appgate/sdp-api-client-go/api/v18/openapi"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"log"
)

func findEntitlementByUUID(ctx context.Context, api *openapi.EntitlementsApiService, id, token string) (*openapi.Entitlement, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source Entitlement get by UUID %s", id)
	resource, _, err := api.EntitlementsIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findEntitlementByName(ctx context.Context, api *openapi.EntitlementsApiService, name, token string) (*openapi.Entitlement, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source Entitlement get by name %s", name)

	resource, _, err := api.EntitlementsGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple Entitlement matched; use additional constraints to reduce matches to a single Entitlement")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find Entitlement %s", name)
}

func ResolveEntitlementFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.EntitlementsApiService, token string) (*openapi.Entitlement, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("entitlement_id")
	resourceName, nok := d.GetOk("entitlement_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of entitlement_id or entitlement_name attributes")
	}

	if iok {
		return findEntitlementByUUID(ctx, api, resourceID.(string), token)
	}
	return findEntitlementByName(ctx, api, resourceName.(string), token)
}

func findAdministrativeRoleByUUID(ctx context.Context, api *openapi.AdminRolesApiService, id, token string) (*openapi.AdministrativeRole, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source AdministrativeRole get by UUID %s", id)
	resource, _, err := api.AdministrativeRolesIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findAdministrativeRoleByName(ctx context.Context, api *openapi.AdminRolesApiService, name, token string) (*openapi.AdministrativeRole, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source AdministrativeRole get by name %s", name)

	resource, _, err := api.AdministrativeRolesGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple AdministrativeRole matched; use additional constraints to reduce matches to a single AdministrativeRole")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find AdministrativeRole %s", name)
}

func ResolveAdministrativeRoleFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.AdminRolesApiService, token string) (*openapi.AdministrativeRole, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("administrative_role_id")
	resourceName, nok := d.GetOk("administrative_role_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of administrative_role_id or administrative_role_name attributes")
	}

	if iok {
		return findAdministrativeRoleByUUID(ctx, api, resourceID.(string), token)
	}
	return findAdministrativeRoleByName(ctx, api, resourceName.(string), token)
}

func findApplianceCustomizationByUUID(ctx context.Context, api *openapi.ApplianceCustomizationsApiService, id, token string) (*openapi.ApplianceCustomization, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source ApplianceCustomization get by UUID %s", id)
	resource, _, err := api.ApplianceCustomizationsIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findApplianceCustomizationByName(ctx context.Context, api *openapi.ApplianceCustomizationsApiService, name, token string) (*openapi.ApplianceCustomization, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source ApplianceCustomization get by name %s", name)

	resource, _, err := api.ApplianceCustomizationsGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple ApplianceCustomization matched; use additional constraints to reduce matches to a single ApplianceCustomization")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find ApplianceCustomization %s", name)
}

func ResolveApplianceCustomizationFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.ApplianceCustomizationsApiService, token string) (*openapi.ApplianceCustomization, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("appliance_customization_id")
	resourceName, nok := d.GetOk("appliance_customization_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of appliance_customization_id or appliance_customization_name attributes")
	}

	if iok {
		return findApplianceCustomizationByUUID(ctx, api, resourceID.(string), token)
	}
	return findApplianceCustomizationByName(ctx, api, resourceName.(string), token)
}

func findApplianceByUUID(ctx context.Context, api *openapi.AppliancesApiService, id, token string) (*openapi.Appliance, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source Appliance get by UUID %s", id)
	resource, _, err := api.AppliancesIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findApplianceByName(ctx context.Context, api *openapi.AppliancesApiService, name, token string) (*openapi.Appliance, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source Appliance get by name %s", name)

	resource, _, err := api.AppliancesGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple Appliance matched; use additional constraints to reduce matches to a single Appliance")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find Appliance %s", name)
}

func ResolveApplianceFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.AppliancesApiService, token string) (*openapi.Appliance, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("appliance_id")
	resourceName, nok := d.GetOk("appliance_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of appliance_id or appliance_name attributes")
	}

	if iok {
		return findApplianceByUUID(ctx, api, resourceID.(string), token)
	}
	return findApplianceByName(ctx, api, resourceName.(string), token)
}

func findConditionByUUID(ctx context.Context, api *openapi.ConditionsApiService, id, token string) (*openapi.Condition, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source Condition get by UUID %s", id)
	resource, _, err := api.ConditionsIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findConditionByName(ctx context.Context, api *openapi.ConditionsApiService, name, token string) (*openapi.Condition, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source Condition get by name %s", name)

	resource, _, err := api.ConditionsGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple Condition matched; use additional constraints to reduce matches to a single Condition")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find Condition %s", name)
}

func ResolveConditionFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.ConditionsApiService, token string) (*openapi.Condition, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("condition_id")
	resourceName, nok := d.GetOk("condition_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of condition_id or condition_name attributes")
	}

	if iok {
		return findConditionByUUID(ctx, api, resourceID.(string), token)
	}
	return findConditionByName(ctx, api, resourceName.(string), token)
}

func findCriteriaScriptByUUID(ctx context.Context, api *openapi.CriteriaScriptsApiService, id, token string) (*openapi.CriteriaScript, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source CriteriaScript get by UUID %s", id)
	resource, _, err := api.CriteriaScriptsIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findCriteriaScriptByName(ctx context.Context, api *openapi.CriteriaScriptsApiService, name, token string) (*openapi.CriteriaScript, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source CriteriaScript get by name %s", name)

	resource, _, err := api.CriteriaScriptsGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple CriteriaScript matched; use additional constraints to reduce matches to a single CriteriaScript")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find CriteriaScript %s", name)
}

func ResolveCriteriaScriptFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.CriteriaScriptsApiService, token string) (*openapi.CriteriaScript, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("criteria_script_id")
	resourceName, nok := d.GetOk("criteria_script_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of criteria_script_id or criteria_script_name attributes")
	}

	if iok {
		return findCriteriaScriptByUUID(ctx, api, resourceID.(string), token)
	}
	return findCriteriaScriptByName(ctx, api, resourceName.(string), token)
}

func findDeviceScriptByUUID(ctx context.Context, api *openapi.DeviceClaimScriptsApiService, id, token string) (*openapi.DeviceScript, diag.Diagnostics) {
	log.Printf("[DEBUG] Data source DeviceScript get by UUID %s", id)
	resource, _, err := api.DeviceScriptsIdGet(ctx, id).Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	return resource, nil
}

func findDeviceScriptByName(ctx context.Context, api *openapi.DeviceClaimScriptsApiService, name, token string) (*openapi.DeviceScript, diag.Diagnostics) {
	var diags diag.Diagnostics
	log.Printf("[DEBUG] Data source DeviceScript get by name %s", name)

	resource, _, err := api.DeviceScriptsGet(ctx).Query(name).OrderBy("name").Range_("0-10").Authorization(token).Execute()
	if err != nil {
		return nil, diag.FromErr(err)
	}
	if len(resource.GetData()) > 1 {
		return nil, AppendErrorf(diags, "multiple DeviceScript matched; use additional constraints to reduce matches to a single DeviceScript")
	}
	for _, r := range resource.GetData() {
		return &r, nil
	}
	return nil, AppendErrorf(diags, "Failed to find DeviceScript %s", name)
}

func ResolveDeviceScriptFromResourceData(ctx context.Context, d *schema.ResourceData, api *openapi.DeviceClaimScriptsApiService, token string) (*openapi.DeviceScript, diag.Diagnostics) {
	var diags diag.Diagnostics
	resourceID, iok := d.GetOk("device_script_id")
	resourceName, nok := d.GetOk("device_script_name")

	if !iok && !nok {
		return nil, AppendErrorf(diags, "please provide one of device_script_id or device_script_name attributes")
	}

	if iok {
		return findDeviceScriptByUUID(ctx, api, resourceID.(string), token)
	}
	return findDeviceScriptByName(ctx, api, resourceName.(string), token)
}
